# 第九章 后端视图

全书完整目录请见：[Odoo 14开发者指南（Cookbook）第四版](README.md)

在此前的章节中，我们学习了Odoo的服务端和数据库层面的知识。本章中将学习Odoo的UI层面的知识。我们将学习如何创建不同类型的视图。除视图外，本章还会讲解组件，如动作按钮、菜单和微件，有助于我们将应用变得对用户更友好。完成本章后，读者将可以设计Odoo后台的UI。注意本章并不包含Odoo的网站部分，会有单独的章节进行讲解。

本章中，我们将讲解如下小节：

- 添加菜单项和窗口动作
- 打开指定视图的动作
- 向表单视图添加内容和微件
- 向表单添加按钮
- 向表单和动作传递参数 - 上下文
- 在记录列表上定义过滤器 - 域
- 定义列表视图
- 定义搜索视图
- 添加搜索过滤器侧边栏
- 修改已有视图 - 视图继承
- 定义文档类型表单
- 使用attrs的动态表单元素
- 定义内嵌视图
- 在表单视图边栏显示附件
- 定义看板视图
- 根据状态在列中显示看板卡片
- 定义日历视图
- 定义图表和透视表视图
- 定义留存（cohort）视图
- 定义仪表盘视图
- 定义甘特视图
- 定义活动视图
- 定义地图视图
- 在树状视图中显示Banner

## 技术准备

贯穿本章，我们将假定你的数据库中安装了base插件并且有一个空的插件模块，可以添加各节中的XML代码到插件声明文件所引用的数据文件中。参见[第三章 创建Odoo插件模块](3.md)，获取更多有关应用插件中修改的信息。

本章的技术要求包含一个在线Odoo平台。

本章中所使用的所有代码都在可GitHub仓库中下载：https://github.com/alanhou/odoo14-cookbook

## 添加菜单项和窗口动作

为用户添加新功能最明显的方式是通过添加菜单项。在点击菜单项时，会发生一些操作。本节将带你学习如何定义这些操作。

我们将创建一个顶级菜单及子菜单，它会打开一个所有客户的列表。

这也可使用网页用户界面借由settings菜单来实现，但更推荐使用XML数据文件，因为在创建我们的插件模块时需要使用此方法。

### 准备工作

本节中，我们需要一个依赖于account模块的模块，因为account模块对res.partner模型添加了一些将字段用于区分客户和供应商记录。因此，如果使用已有模块，请在声明文件中添加对account的依赖。或者可以直接通过[GitHub仓库](https://github.com/alanhou/odoo14-cookbook/tree/main/Chapter09/00_initial_module)获取初始模块。

### 如何实现...

在我们插件模块的XML数据文件中，执行如下步骤：

1. 定义待执行的动作：

   ```
   <act_window id="action_all_customers"
     name="All customers"
     res_model="res.partner"
     view_mode="tree,form"
     domain="[('customer', '=', True)]"
     context="{'default_customer': True}" />
   ```

2. 创建顶级菜单，如下：

   ```
   <menuitem id="menu_custom_top_level"
     name="My App menu"
     web_icon="my_module,static/description/icon.png"/>
   ```

3. 在菜单中引用我们的动作：

   ```
   <menuitem id="menu_all_customers"
     parent="menu_custom_top_level"
     action="action_all_customers"
     sequence="10"/>
   ```

如果我们现在升级模块的话，会看到一个可打开名为All Customers子菜单的顶级菜单My App menu。点击该菜单项会打开一个所有客户的列表。

### 运行原理...

第一个XML元素act_window，定义了一个展示带有所有客户列表视图的窗口动作。我们使用了最重要的属性：

- name：用作动作所打开视图的标题。
- res_model：这是要使用的模型，我们使用res.partner，Odoo在这里存储着所有的合作伙伴和地址，包括客户。
- view_mode：这会列出可用的视图类型。它是一个视图类型的逗号分隔值。默认值为list, form，会让列表视图和表单视图可用。如果你只是想要显示日历视图和表单视图，那么view_mode的值应为calendar, form。其它可选的视图选项有kanban, graph, pivot, calendar, cohort和dashboard。我们会在后续的小节中学习这些视图。
- domain：这是个可选项，让我们可设置视图中可用记录的过滤器。本例中我们想要将成员限制为仅包含客户。我们会在本章*在记录列表上定义过滤器 - 域*一节中更深入地进行学习。
- context：它可以设置打开的视图中可用的值，并影响它们的行为。本例中，在新记录上，我们希望客户排名的默认值为True。这会在本章*向表单和动作传递参数 - 上下文*一节中进行详细讲解。
- limit：这会设置列表视图中可见的记录默认数量。本例，我们将其限定为20，但如果没有为limit赋值，Odoo会使用默认值80。

> **📝~~小贴士：~~**~~在老代码中，你会经常看到tree视图模式。这是截至并包含Odoo 11中所使用的内部名称。版本12还接收该值，但会等同于list来进行处理。~~

接下来，我们创建顶级菜单到可点击的末梢菜单项的菜单项等级。menuitem元素最重要的属性如下：

- name：它用于菜单项所展示的文本。如果你的菜单项关联有动作，可以留空，因为此时会使用动作名。
- parent (在使用record元素时为parent_id)：这是引用父级菜单项的 XML ID。不包含父级的菜单项为顶级菜单。
- action：这是引用要被调用的动作的XML ID。
- sequence：它用于对兄弟菜单项排序。
- groups (record标签中为groups_id)：这是一个可选项，为可访问该菜单项的用户组列表。若留空，则对所有用户都可用。
- web_icon：该选项仅用于顶级菜单。它会在企业版本中显示应用的图标。

窗口动作自动决定以所希望的类型（form, tree等等）对目标模型查找所使用的视图，并选择序号最低的那个。

act_window和menuitem是隐藏所进行操作的快捷XML标签。如果不想使用快捷XML标签，那么可以通过该<record>标签创建一个ir.actions.act_window和ir.ui.menu模型的记录。例如，如果想要通过<record>加载act_window，可以这么做：

```
<record id='action_all_customers' model='ir.actions.act_window'>
  <field name="name">All customers</field>
  <field name="res_model">res.partner</field>
  <field name="view_mode">tree,form</field>
  <field name="domain">[('customer', '=', True)]</field>
  <field name="context">{'default_customer': True}</field>
  <field name="limit">20</field>
</record>
```

你可以相同的方式通过<record>创建menuitem。

> 📝**重要信息：**注意menuitem快捷标签中使用的名称可能不会映射到使用record元素（parent应为parent_id，groups应为groups_id）时所用的字段名。

要创建菜单，网页客户端从ir.ui.menu读取所有的记录并从parent_id字段推导它们的等级。菜单还会根据赋给菜单和动作的模型和组的用户权限来进行过滤。在用户点击菜单项时，执行它的动作。

### 扩展知识...

窗口动作还支持target属性，用于指定如何展现视图。可选项如下：

- **current**：这是默认值，在网页客户端的主内容区域打开该视图。
- **new**：在弹窗中打开视图。
- **inline**：类似于current，但以编辑模式打开表单并禁用了Action菜单。
- **fullscreen**：动作会覆盖整个浏览器窗口，因此会遮挡住菜单。有时，称之为平板（tablet）模式。
- **main**：类似current，但还会清除掉面包屑导航。

窗口动作的view_type属性现在大多已经淘汰。默认的表单的替代为tree，会引起分组列表渲染一个等级树。不要将这个属性与本节*运行原理*中使用和讲解的view_mode属性相混淆，那是决定所使用的视图类型的。

对于窗口动作有一些额外的可用属性，在act_window快捷标签中不支持。要使用这些属性，我们需要使用带有如下字段的record元素：

- res_id：如果打开一个表单，你可以通过在这里设置其ID来打开指定记录。这对于多步骤向导或者在你需要经常查看或编辑指定记录时都非常有用。
- search_view_id：这会指定一个具体的搜索视图来用作树状和图表视图。
- ~~auto_search：默认为True。如果对象的搜索非常耗时且/或消耗大量资源的话将其设置为False。通过这种方式，用户可以重审搜索参数并在满意时按下Search。使用默认值搜索会在动作打开时立即触发。~~

记住左上角的菜单（或是企业版中应用的图标）及顶栏中的菜单都是由菜单项所组成。唯一的不同的是左上角中菜单没有父级菜单，但顶栏上的这些菜单有顶栏的相应菜单项作为父级。在左栏中，等级结构更为明显。

同时应记住出于设计原因，如果第二级菜单有子菜单时第一级菜单会打开下拉菜单。Odoo会根据子菜单项的排序打开第一个菜单项动作。

参照如下内容来学习有关菜单和视图的更多知识：

- ir.actions.act_window是最常见的动作类型，但菜单可引用任意类型的动作。技术上而言链接一个客户端动作、服务端动作或在ir.actions.*命名空间中所定义的任意其它模型都毫无分别。只是在后台由什么动作组成上会存在差别。
- 如果你只需要调用具体动作稍微多一点的灵活性，使用返回窗口动作的服务端动作。如果你需要完全的灵活性，使用客户端动作（ir.actions.client），它允许有一个完全自定义的用户界面。但是，仅在没有其它选择时才考虑使用它，因为这样会损失掉大量的Odoo便捷帮助工具 。

### 其它内容

- 有关所有视图过滤器的更深入讲解参见本章的*在记录列表上定义过滤器 - 域*一节

## 打开指定视图的动作

在未指定时窗口动作自动决定所使用的视图，但有时，我们希望一个动作打开具体某一视图。

我们会为res.partner模型创建一个基本表单视图，并且随后新建一个具体打开该表单视图的窗口动作。

### 如何实现...

1. 定义partner的最小化树状和表单视图：

   ```
   <record id="view_all_customers_tree" model="ir.ui.view">
     <field name="name">All customers</field>
     <field name="model">res.partner</field>
     <field name="arch" type="xml">
       <tree>
         <field name="name" />
       </tree>
     </field>
    </record>
    <record id="view_all_customers_form" model="ir.ui.view">
     <field name="name">All customers</field>
     <field name="model">res.partner</field>
     <field name="arch" type="xml">
       <form>
         <group>
           <field name="name" />
         </group>
       </form>
     </field>
    </record>
   ```

2. 更新

   添加菜单项和窗口动作

   一节中的动作来使用新的表单视图：

   ```
   <record id="action_all_customers_tree"
     model="ir.actions.act_window.view">
     <field name="act_window_id" ref="action_all_customers" />
     <field name="view_id" ref="view_all_customers_tree" />
     <field name="view_mode">tree</field>
     <field name="sequence" eval="2"/>
   </record>
   <record id="action_all_customers_form"
     model="ir.actions.act_window.view">
     <field name="act_window_id" ref="action_all_customers" />
     <field name="view_id" ref="view_all_customers_form" />
     <field name="view_mode">form</field>
     <field name="sequence" eval="2"/>
   </record>
   ```

现在如果打开菜单并点击列表中的成员，你会看到刚刚定义的最小化表单和列表。

### 运行原理...

这次，我们使用了针对任意记录类型通用XML代码，即带有所需 id 和model属性的record元素。record元素上的id属性是任意一个在插件中唯一的字符串。model属性引用所希望创建的模型。假定我们想要创建视图，则需要创建一个 ir.ui.view模型的记录。在该元素内， 我们设置通过model属性选取模型中定义的字段。对ir.ui.view最关键的字段是model和arch。model字段包含所想要定义视图的模型而arch字段包含视图本身的定义。稍后我们就会讲到它的内容。

name字段虽然不是严格必要，但有助于通过视图调试问题，因此将其设置为一个字符串可以告诉我们这个视图的作用。该字段的内容不对用户显示，因此可以填入任意对你有意义的技术性提示。如果不进行设置，会得到一个包含模型名和视图类型的默认名称。

#### ir.actions.act_window.view

我们所定义的第二条记录与在前面*添加菜单项和窗口动作*小节中定义的act_window一同发挥作用。我们已经知道通过设置view_id字段，可以选择第一个视图模式所使用的视图。但是，假设我们将view_mode设置为tree, form视图，view_id则应选择树状视图，但我们想要设置的是表单视图，放在第二位。

如果你发现自己遇到同样的状况，使用ir.actions.act_window.view模型，它会对哪种视图类型加载何种视图进行更细致的控制。这里定义的前两个字段是引用其它对象的通用方式示例，保持元素体为空，但添加一个ref属性，它包含所想要引用的对象的XML ID。因此这里所发生的是我们在act_window_id字段中引用前一小节中的动作，并引用我们刚刚在view_id中所创建的视图。然后，虽非严格必要，我们添加了对同一动作这一视图赋值相对于其它视图赋值的序号。仅在通过创建多条ir.actions.act_window.view记录为不同视图模式添加视图时才有关联。

> 📝**重要信息：**一旦定义了 ir.actions.act_window.view记录，其优先级高于在动作的view_mode字段中所填写内容。因此在前面的记录中，看不到列表视图，仅有表单视图。需要添加另一个指向针对res.partner模型列表视图的ir.actions.act_window.view。

### 扩展知识...

我们在*添加菜单项和窗口动作*一节中学习了可以将act_window替换为<record>。如果想要使用自定义视图，可以遵循给定的语法：

```
<record id='action_all_customers'
  model='ir.actions.act_window'>
  <field name="name">All customers</field>
  <field name="res_model">res.partner</field>
  <field name="view_mode">tree,form</field>
  <field name="domain">[('customer', '=', True)]</field>
  <field name="context">{'default_customer': True,
    'tree_view_ref': 'my_module.view_all_customers_tree'.
    'form_view_ref': 'my_module.view_all_customers_form'
  }</field>
  <field name="limit">20</field>
</record>
```

上例只是act_window的另一种书写方式，在Odoo的基础代码中，会发现存在这两种类型的动作。

## 向表单视图添加内容和微件

前面一节展示了如何为一个动作选择指定的视图。现在我们将演示如何让表单视图更为实用。本节中，我们将使用*在指定视图中打开动作*一节中所定义的表单视图。在表单中视图中添加微件和内容。

### 如何实现...

1. 定义表单视图的基础结构：

   ```
   <record id="view_all_customers_form" model="ir.ui.view">
     <field name="name">All customers</field>
     <field name="model">res.partner</field>
     <field name="arch" type="xml">
       <form>
         <!--form content goes here -->
       </form>
     </field>
   </record>
   ```

2. 头部栏通常用于放置动作按钮和进度管道，在表单中使用如下代码添加一个头部栏：

   ```
   <header>
     <button type="object" name="open_commercial_entity"
       string="Open commercial partner"
       class="btn-primary" />
   </header>
   ```

3. 在表单中添加字段，使用group标签进行视觉上的组织：

   ```
   <group string="Content" name="my_content">
     <field name="name" />
     <field name="category_id" widget="many2many_tags" />
   </group>
   ```

现在表单中应该会显示带有一个按钮的顶栏以及两个垂直对齐的字段，如下图所示：

![图9.1 – 表单视图截图](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/202104250331213.png)

图9.1 – 表单视图截图

### 运行原理...

我们先来看ir.ui.view模型中的arch字段。首先，注意视图使用用XML进行定义，因此需要向arch字段传递type="xml"属性，否则会让解析器不知所措。同时还要求视图定义中必须包含良好的XML结构，否则在加载这个代码段时会出现问题。

下面我们来逐一学习前面所使用的标签并对其它的可用标签进行总结。

#### form

在定义表单视图时，arch字段的第一个元素必须为form元素。内部通过它来获取记录的type字段，

除下面的元素以外，还可以在form标签内使用自定义的HTML。对Odoo未知的元素算法均会视为普通的HTML并直接传递给浏览器。要谨慎使用，因为所填充的HTML会与Odoo元素生成的HTML代码进行交互，可能会让渲染出现偏差。

#### header

这个元素是显示在表单头部中元素的容器，它被渲染为一个白条。通常会像示例中一样将动作按钮放在这里。此外，如果模型有state字段的话，也可以选择状态栏。

#### button

button元素用于允许用户触发某一动作。参见*向表单添加按钮*一节获取更多信息。

#### group

<group>元素是Odoo的主要元素，用于组织内容。<group>元素中的字段以它们的标题进行渲染，并且相同组中的所有字段进行了对齐，这样在视觉上可以看出它们属于相同组。还可以内嵌<group>元素，这会让Odoo将所包含字段以相邻的列进行渲染。

通常，应使用<group>组织方式来在表单视图中显示所有字段，仅在必要时才考虑其它元素，如<notebook>, <label>, <newline>等。

如果对组赋值了string属性，它的内容会渲染为组的标题。

也应培养为字段的每个逻辑组赋值name的习惯。这一名称对用户不可见，但在下面小节中重载视图时会很有帮助。在表单定义中保持该名称唯一，可避免引用时分不清哪一组的混淆。不要使用string属性来做区分，因为string值会因为翻译的原因而最终发生改变。

#### field

为实际显示和操作数据，表单视图应包含一些field元素。示例如下：

```
<field name="category_id" widget="many2many_tags" readonly="1"/>
```

它们有一个必填属性，name，指代模型中的字段名称。早前，我们让用户可以编辑partner的分类。如果我们想禁用字段的编辑功能，可以将readonly属性设置为1或True。这个属性实际可以包含一小段Python代码，所以readonly="2>1"也会让该字段只读。对于invisible属性也是如此，此时会从数据库中读取值，而不对用户展示。稍后我们会了解其使用场景。

你一定注意到了分类字段的widget属性。它定义了字段中的数据向用户展示的方式。每种类型的字段都有一个标准微件，因此无需显式的指定widget。但有些类型提供了多种展现方式，这时你可能会选择非默认的那种。完整的可用微件列表超出了本节的范畴，请参照Odoo源代码来进行尝试。参见[第十四章 CMS网站开发](14.md)来了解如何制作自己的微件。

#### Notebook和page

如果模型字段过多，那么可以使用<notebook>和<page>标签来创建选项卡。<notebook>标签中的每个<page>会新建一个选项卡，页面中的内容为选项卡的内容。下例中创建2个选项卡、每个选项卡3个字段：

```
<notebook>
  <page string="Tab 1">
    <field name="field1"/>
    <field name="field2"/>
    <field name="field3"/>
  </page>
  <page string="Tab 2">
    <field name="field4"/>
    <field name="field5"/>
    <field name="field6"/>
  </page>
</notebook>
```

<page>标签中的string属性为选项卡的名称。在<notebook>标签中仅能使用<page>标签，但在<page>标签中可以使用任意其它元素。

#### 通用属性

在大多数元素（包含group, field和button）中，都可以设置attrs和groups属性。示例如下：

```
<field name="category_id"
    attrs="{'readpnly': [('state', '='. 'done')]}"
    groups="base.group_no_one"/>
```

attrs属性会在*使用attrs的动态表单元素*一节中进行讨论，groups属性让我们可仅向某些分组成员显示一些元素。简单地说，组的完整XML ID（多个组由逗号分隔）是属性，元素对非指定组内的成员均不可见。

#### 其它标签

有些情况下可能想规避严格的分组布局。例如，如果希望记录的name字段以标题进行渲染，字段的标签会干涉到外观。这种情况下，不要将字段放到group元素中，而是使用普通的HTML h1元素。然后在h1元素前，为字段名添加一个label元素及for属性：

```
<label for="name" />
<h1><field name="name" /></h1>
```

这会将字段的内容渲染为大标题，但字段名以小号类型在大标题之上出现。这基本上就是标准的partner表单的形式。

如果需要在分组内有换行，可以使用newline元素。内容为空：

```
<newline />
```

另一个有用的元素是footer。在以弹窗打开表单时，在这里放动作按钮会比较好。它也会以单独栏进行渲染，与header元素类似。

表单视图还有一些特殊的微件，如web_ribbon。可以配合<widget>标签使用，如下：

```
<widget name="web_ribbon" title="Archived" bg_color="bg-danger" attrs="{'invisible': [('active', '=', True)]}"/>
```

可以使用attrs来根据条件隐藏或显示丝带角标。不清楚attrs也不必担心。在本章的*使用attrs的动态表单元素*一节中会讲到。

**译者注：**丝带角标？这算什么烂翻译？哈哈，这个ribbon和 Excel中又不同，英语哪里比得我们汉语博大精深，一个词到处用。Ribbon对于西方世界想必有神圣的意义，Pink Ribbon, Red Ribbon...，不清楚的问谷哥、度娘，这里还是上图为妙：

![丝带角标](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021042504485370.png)

> **小贴士：**不要对XML节点使用string属性（或任何其它的可翻译属性），这会在其它语言中因继承前应用翻译的原因破坏视图的重载。

### 扩展知识...

因表单视图基本上是带一些插件的HTML，Odoo还对CSS类做了一些扩展使用。其中有两个非常有用的是oe_read_only和oe_edit_only。这两个类会让元素分别在只读模式或仅在编辑模式下可见。例如，要让label仅在编辑模式下可见，用如下代码：

```
<label for="name" class="oe_edit_only" />
```

另一个非常有用的类是oe_inline，可以在字段中使用它来将内容渲染为行内元素，以避免引起不必要的换行。在将字段嵌入文本或其它标记标签时使用该类。

此外，form元素可包含 create, edit和delete属性。如果将其中的属性的设为false，该表单相应的动作就不可用。如未进行显式的设置，动作的可用性会由用户的权限来决定。注意这里的目的仅是针对UI层面，不要使用它们来进行权限控制。

### 其它内容

微件和视图已经提供了大量的功能，但迟早你会碰到已有组件和视图无法满足的需求。参见下面的小节来创建自己的视图和微件：

- 参见本章中的*向表单添加按钮*一节了解使用button元素触发动作的知识。
- 参见[第十五章 网页客户端开发](15.md)中*创建自定义组件*一节来定义你自己的组件。
- 参见[第十五章 网页客户端开发](15.md)中*新建一个视图*一节来创建你自己的视图。

## 向表单添加按钮

按钮在表单视图中用于处理用户动作。我们在前面的表单视图中添加过一个按钮，但有好几种不同类型的按钮可供使用。本节将添加另一个按钮，用于让用户打开其它视图。将下面的代码同样放到header元素中。

### 如何实现...

添加一个引用动作的按钮：

```
<button type="action"
  name="%(base.action_partner_category_form)d"
  string="Open partner categories" />
```

![向表单添加按钮](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021042512275339.png)

### 运行原理...

按钮的type属性决定其它字段的语法，那么我们先来看看有哪些可用值：

- action：这会让按钮调用一个 ir.actions.*命名空间中所定义的动作。name属性需要包含该动作的数据库ID，可以方便地让Odoo通过包含所需动作XML ID 的Python格式化字符串来进行查找。
- object：调用当前模型的一个方法。name属性包含函数名称。
- string属性用于赋值用户所看到的文本。

### 扩展知识...

使用btn-primary CSS类来渲染高亮的按钮，用btn-default来将其渲染为普通按钮。普通按钮通常在向导中用作取消按钮或提供一个视觉上不明显的二级动作。设置oe_link类会让按钮看起来像一个链接。也可以使用其它bootstrap按钮类来获取不同的按钮颜色。

对object类型按钮的调用会返回一个描述动作的字典，然后在客户端进行执行。这样可以实现多屏向导或是仅打开另一条记录。

> 📝注意点击按钮总是会让客户端在运行该方法前发送一个写入或创建的调用。

还可以通过替换string属性来把内容放到button标签中。这通常用于按钮框，在*定义文档样式表单*一节中会讲到。

## 向表单和动作传递参数 - 上下文

Odoo内部的每个方法都可以访问一个名为context的字典，这是由动作带到分发该动作的方法中的。UI层面也可以进行访问，有多种通过设置上下文中值方式来进行更改。本节中，我们将通过使用语言、默认值和隐式过滤器来探讨使用这一机制的几种应用场景。

### 准备工作

虽然不是特别必要，如未安装法语可安装一下来增加本节的趣味性。参见[第十一章 国际化](11.md)来了解如何实现。如果你本来使用的就是法语数据库，则将fr_FR修改为其它的语言；en_US用作英语(zh_CN为简体中文)。另外，对一个客户点击Active（悬浮时变为Archive）按钮来进行存档，验证下这个成员是否不再出现在列表中。

### 如何实现...

1. 新建一个动作，与

   添加菜单项和窗口动作

   一节很相似（好吧，爱国的我们还是使用中文好了，比利时人才爱法语 - Je suis Alan, coment allez-vous?）：

   ```
   <act_window
       id="action_all_customers_cn"
       name="所有客户"
       res_model="res.partner"
       domain="[('customer_rank', '>', 0)]"
       context="{'lang': 'zh_CN', 'default_lang': 'zh_CN', 'active_test':False, 'default_customer_rank':1}"
   />
   ```

2. 添加一个调用该动作的菜单。这部分留作读者练习。

在打开该菜单时，视图会显示为中文，而你创建一个新成员时，中文也将作为预选的语言。一个不太明显的区别是我们还是会看到未激活（存档）的成员记录。

![向表单和动作传递参数 - 上下文](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021042512532353.png)

### 运行原理...

上下文字典有几个数据源。首先，读取当前用户记录的一些值（lang和tz为用户的语言和时区）。然后，有一些插件会添加它们自己使用的一些键。此外，UI添加当前使用的模型和记录作为键（active_id, active_ids, active_model）。还有在*在指定视图中打开动作*一节中我们学习到了可以在动作中添加自己的键。这些会合并到一起并传递给背后的服务端函数，以及客户端UI。

因此，通过设置lang上下文键，我们将展示语言强制为汉语。你会注意到这并不会修改整体的UI语言，因为仅仅是我们所打开的列表视图位于这一上下文作用域内。其它的UI已由用户原有语言中所包含的其它上下文所载入。但是，如果你在这个列表视图中打开一个记录，它也会以汉语进行展示，并且如果你在该表单中打开一条关联记录或者按下执行动作的按钮，都会显示为汉语。

通过设置default_lang，我们为这个上一文域中所创建的每条记录设置了一个默认值。通用模式是default_$fieldname: my_default_value，这样我们为新创建的成员设置了默认值。假定我们的菜单是有关客户的，设置了default_customer_rank: 1来作为客户的默认排名。但是，这是res.partner的模型级别的默认值，因此它不会修改任何值。对于标量字段，语法和Python代码编写方式一致：字符串放在引号中，数值字段保持不变，布尔字段为True 或 False。关联字段语法要更为复杂一些；参见[第六章 管理模块数据](6.md)来学习如何进行编写。

> 📝注意上下文中设置的默认值会覆盖模型定义中所设置的默认值，因此在不同场景下会有不同的默认值。

最后一个键是active_test，它具有非常特殊的语法。对每个带有名为active字段的模型，Odoo会自动过滤掉该字段为False的记录。这也是取消勾选该字段的成员会在列表中消失的原因。通过设置该键，我们可以去除这种行为。

> 📝重要：这对于 UI 的独立控制非常有用，但它在需要确保操作应用于所有记录而非 active 记录时在 Python 代码中会更为有用。

### 扩展知识...

在定义上下文时，需要访问一些变量，最重要的一个变量是uid，值为当前用户的ID。需要用它来设置默认过滤器（参见下一节*在记录列表上定义过滤器 - 域*）。再者，可以访问context_today函数和current_date变量，前者为代表当前日期的date对象，在用户的时区中可以看到，后者是以UTC时间显示的当前日期，格式为YYYY-MM-DD。要将date字段的默认值设置为当前日期，使用current_date，默认的过滤器中应使用context_today()。

此外，可以通过Python的datetime, time和relativedelta类的子集来进行一些日期运算。

> **重要贴士：**大部分的域在客户端运行。出于安全的考虑禁止服务端域的运行。在使用客户端运行时，不致使系统崩溃的最好选择是在JavaScript中实现部分Python功能。Odoo中内置了一个小型的JavaScript Python解释器，通常足够用了。
>
> <act_window />快捷标签中当心context变量的使用。它们在安装时运行，和你所想要的相差甚远。如果需要在上下文中使用变量，请用<record />。

我们还可以对按钮添加不同的上下文。和在动作中添加上下文键的方式相同。这样按钮调用的函数或动作会在给定的上下文中运行。

大部分以Python运行的表单元素属性也可访问上下文字典。invisible和readonly属性即为这种情况。因此，在希望元素有时在表单中显示，有时又不显示时，设置invisible属性为context.get('my_key')。对于导致字段不可见的动作，设置上下文键为my_key: True。这种策略让我们无需对不同情况进行重写即可调整表单。

也可以在关联字段上设置上下文，它会影响到字段载入的方式。通过将form_view_ref或tree_view_ref键设置为视图的完整XML ID，可以为该字段选择指定的视图。在同一对象有多个相同类型的视图时这会很有必要。没有这个键时，获取到最小序号的视图，很多时候不需要这一效果。

### 其它内容

- 上下文还用于设置默认搜索过滤器。可以在本章*定义搜索视图*一节中学习有关默认搜索过滤器的知识。
- 更多默认设置参见下一节：*在记录列表上定义过滤器 - 域*。
- 学习如何安装中文，参见[第十一章 国际化](11.md)。
- 可参见[第六章 管理模块数据](6.md)学习关联字段的编写语法。

 在记录列表上定义过滤器 - 域

我们已经在本章第一节中学习到了作用域的示例，即[('customer', '=', True)]。通常，我们需要通过动作显示所有可用记录的一个子集，或仅允许记录的一部分作为many2one的关联对象。在Odoo中描述这些过滤器的方式就是使用域。本节描述如何使用域来显示一部分成员。

### 如何实现...

要通过动作显示成员的一个子集，需要执行如下步骤：

1. 为不讲法语的客户添加一个动作：

   ```
   <record id="action_my_customers" model="ir.actions.act_window">
       <field name="name">我不说法语的所有客户</field>
       <field name="res_model">res.partner</field>
       <field name="domain">
           [('type', '=', 'contact'), ('user_id', '=', uid), ('lang', '!=', 'fr_FR')]
       </field>
   </record>
   ```

2. 为客户或供应商添加一个动作：

   ```
   <record id="action_no_email_or_phone" model="ir.actions.act_window">
       <field name="name">没有email或电话的客户</field>
       <field name="res_model">res.partner</field>
       <field name="domain">['|', ('phone', '=', False), ('email', '=', False)]</field>
   </record>
   ```

3. 添加调用这些动作的菜单。这部分留作读者练习。

### 运行原理...

域的最简单形式为一个带有三个元素元组的列表，第一个元素中包含要操作模型的字段名，第二个元素为运算符，前两个都采用字符串的形式，第三个值为该字段需要进行检查的值。上例中就是这么做的，可解释为：所有这些条件应作用于我们所需的记录。这实际上是一个简写，因为域知道那两个前置运算符& 和 |，其中&是默认值。因此规范化的形式第一个域应这样写：

```
['&', '&', ('type', '=', 'contact'), ('user_id', '=', uid), ('lang', '!=', 'fr_FR')]
```

译者注：在 xml 中以上写法会报错，需将&转义，写为

```
['&amp;','&amp;',('type', '=', 'contact'), ('user_id', '=', uid), ('lang', '!=', 'fr_FR')]
```

另在测试建议加上--dev=all，译者在测试时出现过设置为法语但未被过滤的情况，添加--dev=all 则正常，是未正常更新或缓存原因尚不确定

虽然更长的表达式有些难于阅读，但前置运算符的优势在于它们的作用域进了严格的定义，让我们不必担心运算符优级级和括号的使用。有两个表达式，第一个&对应'&', ('type', '=', 'contact'), ('user_id', '=', uid) 来作为第一个运算项， ('lang', '!=', 'fr_FR')作为第二个运算项。然后，第二个&对应的是('type', '=', 'contact')作为第一个运算项，而('user_id', '=', uid) 作为第二个运算项。

第二步中，我们要写出完整形式，因为用到了 | 运算符。

举个例子，假设我们需要一个这样复杂的域： ['|', ('user_id', '=', uid), '&', ('lang', '!=', 'fr_FR'), '|', ('phone', '=', False), ('email', '=', False)]。参见下图了解域是如何运行的：

![图9.2 – 作用域的运行](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021042920035135.jpg)

图9.2 – 作用域的运行

还有一个 ! 运算符用于取反，但既然有逻辑等式和像 !=和 not in 这样的取反比较运算符，实际上并没有必要。

> 📝注：注意这是一个一元前置运算符，因此仅用于域中所接的表达式而不是其所跟的所有内容。

注意在编写窗口动作或其它客户端的作用域时右边的操作项不需要是固定值。可以使用在*向表单和动作传递参数 - 上下文*一节中所描述的同样的最小化 Python代码，因此可以编写类似*上周修改*或*仅自己的客户*等过滤器。

### 扩展知识...

前述的域仅用于模型自身的字段，但我们常常需要根据所关联记录的属性来进行过滤。这样，可以使用@api.depend定义或关联字段中所使用的标记法：创建一个当前模型对所需要过滤模型的点号路径。搜索销售人员是以 G 字母开头的组成员的客户，可以使用[('user_id.groups_id.name', '=like', 'G%')] 域。路径可以很长，因此只需要确保当前模型和所需过滤模型之间存在关联字段即可。

#### 运算符

下表列出了可以使用的运算符及它们的语法：

| 运算符（等价符号）       | 语法                                                         |
| :----------------------- | :----------------------------------------------------------- |
| =, !=, <>                | 第一个为精准匹配，第二为不等于，最一个是已淘汰的不等于标记。 |
| in, not in               | 这会检查值是否在右侧运算项列表中。以 Python 列表的形式给出：[('uid', 'in', [1, 2, 3])]或[('uid', 'not in', [1, 2, 3])]。 |
| <, <=                    | 小于，小于等于                                               |
| >, >=                    | 大于，大于等于                                               |
| like, not like           | 检查右侧运算项是否包含在值中（子字符串）。                   |
| ilike, not ilike         | 与上面一个相同，但忽略大小写。                               |
| !ERROR! unexpected comma | 可以在这里搜索模式：%匹配任意字符串，_匹配单个字符。这与 PostgreSQL中的 like 等价。 |
| child_of                 | 对带有 parent_id 字段的模型，它搜索右侧运算项的子项。右侧运算项包含于结果中。 |
| =?                       | 如果右侧运算项为 false 运行结果为 true；否则它和=相同。这用于由程序生成的域，在设置值时用值进行过滤，否则忽略该值。 |

表 9.1

注意某些运算符仅用于特定的字段和值。例如，[('category_id', 'in', 1)]无效，会报错，而**[('category_id', 'in', [1])]则是有效的作用域。**

#### 使用域进行搜索的隐患

对于传统字段这些都没有问题，但在搜索非存储函数字段时这是一个广为人知的问题。通过[第四章 应用模型](https://alanhou.org/odoo-14-application-models/)中所讲到的，在代码中加入搜索函数即可处理这个问题。

另一个困扰开发人员的问题是Odoo对于使用否定运算符搜索one2many和many2many字段的处理。假设有一个带有A标签的用户并使用 [('category_id.name', '!=', 'B')]搜索。会照预期在结果中显示该用户，但在给该用户加上 B 标签时，它还是出现在结果中，因为对于搜索算法来说，有一条关联的记录（本例中为 A）并不符合这一条件。这时删除 A 标签， B 成为其唯一标签，可以过滤掉该用户。如果再删除 B 标签，该用户已无标签，它还是会被过滤掉，因为关联记录上的条件预设的是存在该记录。但在其它情况中，这是所希望的结果，所以不应修改标准行为。如果要采取不同做法，添加一个照你所需方式运行的搜索函数。

> 📝**重要信息**：人们在编写 XML 文件并用到域时经常会忘记这点。需要对小于运算符进行转义。搜索指定日期前所创建的记录需要在 XML 中写成[('create_date', '&lt;', current_date)] 。

Odoo中大量使用到了作用域。你会发现它在Odoo中无处不在，用于搜索、过滤、安全规则、搜索视图、用户动作等等。

如果需要操作不是由程序创建的域，使用odoo.osv.expression中所提供的工具函数。is_leaf, normalize_domain, AND和OR函数让我们可以按 Odoo 相同的方式合并域。不要自行操作，因为有很多需要考虑到的极端情况，很可能会注意不到。

### 其它内容

有关域的标准应用，参见*定义搜索视图*一节。

## 定义列表视图

在对表单视图花了一番功夫后，现在我们来快速地看下如何定义列表视图。内部有些地方称之为树状视图，另一些地方则称其为列表视图，但因为 Odoo 视图框架中还有另一种结构称为 tree，我们将保持列表视图的叫法。

### 如何实现...

1. 定义列表视图：

   ```
   <record id="tree_all_contacts" model="ir.ui.view">
       <field name="model">res.partner</field>
       <field name="arch" type="xml">
           <tree decoration-bf="customer_rank &gt; 0"
                 decoration-danger="customer_rank &gt; 0 and supplier_rank &gt; 0" decoration-warning ="supplier_rank &gt; 0">
               <field name="name"/>
               <field name="user_id" widget="many2one_avatar_user"/>
               <field name="state_id" optional="hide"/>
               <field name="country_id" optional="show"/>
               <field name="customer_rank" invisible="1"/>
               <field name="supplier_rank" invisible="1"/>
           </tree>
       </field>
   </record>
   ```

2. 在本章

   添加菜单项和窗口动作

   一节中所创建的动作中注册一个列表视图。

   ```
   <record id="action_all_contacts" model="ir.actions.act_window">
       <field name="name">All Contacts</field>
       <field name="res_model">res.partner</field>
       <field name="view_mode">tree,form</field>
       <field name="context">{'tree_view_ref': 'my_module.tree_all_contacts'}</field>
       <field name="limit">20</field>
   </record>
   ```

3. 添加菜单调用这些动作。这部分留作读者练习。

安装/升级模块。之后，就可以看到客户的列表视图了。根据不同的条件各行也会显示不同的样式。

译者注：对于列表视图部分的颜色显示，为便于查看，译者做了一下调换，另 Odoo 13开始移除了 customer和 supplier 布尔字段，所以这里使用的是 customer_rank 和 supplier_rank，在 name_search 中通过res_partner_search_mode上下文来实现搜索：

```
context={'res_partner_search_mode': 'supplier'}
```

![定义列表视图](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021043001424946.png)

### 运行原理...

我们已经可以知道这里发生了什么。我们定义了一个视图，类型为 tree，并使用ir.actions.act_window.view元素将其关联到我们的动作上。因此，唯一剩下要讨论的是 tree 元素及其语法。使用列表并没有很多的设计选项，该元素仅有的有效子元素是field和button元素。也可以在列表视图中使用一些微件，本例中，我们使用了many2one_avatar_user这个小部件。列表视图支持一个特殊的微件handle。只针对列表视图，用于整型字段，渲染为一个可拖拽手柄，让用户可通过将列表中的行拖拽到不同位置来更新字段值。用于排序或优先级字段。

通过使用optional，可以有选择地显示字段。对字段添加optional属性让用户可以随时在UI界面中显示或隐藏某列。本例中，我们对country和state字段使用了该属性。

这里的新内容是 tree 元素中的decoration属性。它包含在行中选择哪种字体及/或颜色的规则，设置的形式为decoration-$name="Python code"。所有的匹配转换成相应的 CSS 类，因此前面的视图将既是供应商又是客户的用户渲染为红色，客户渲染为加粗字段，而供应商为黄色。在Python代码中，仅能使用在视图定义中的字段名称，因此我们还需要customer_rank和supplier_rank字段。这些字段设为隐藏，因为我们只是需要数据而不用向用户展示这些字段。可以使用的类有decoration-bf (加粗), decoration-it (斜体)以及bootstrap类decoration-danger, decoration-info, decoration-muted, decoration-primary, decoration-success和decoration-warning。

### 扩展知识...

对于数值字段，可以添加一个 sum 属性来让该字段以在属性中设置为提示的文本进行加总。不太常见的属性有avg, min和max分，别用于显示平均值，最小值和最大值。注意这4个属性仅用于当前可见的记录，因此可能需要调整动作的**limit**来让用户可即时看到所有记录（参见*添加菜单项和窗口动作*一节）。

tree元素有一个非常有趣的属性editable。如果将其设置为top或bottom，列表的行为完全不同。没有它的话，点击某行会打开该行的表单视图。带上它点击某行会让其在行内可编辑，将可见字段渲染为了表单字段。这对于本章后面定义内嵌视图一节中讨论的嵌套列表视图尤为有用。top或 bottom 选项关乎新行在列表的顶部还是底部添加。

默认记录根据所显示模型的_order属性进行排序。用户可通过点击列的头部来修改排序，但也可通过在tree元素中设置default_order属性来设置不同的初始排序。语法与_order中的相同。

默认，记录按照所显示模型的_order属性进行排序。用户可通过点击列头来更换排序，但也可以在**tree**元素中通过设置**default_order**属性来设置不同的初始排序，语法与**_order**中的相同。

> ℹ️排序通常会让新开发者感到沮丧。因为Odoo通过PostgreSQL来完成这一工作，只能对PostgreSQL已知的字段排序并且这些字段需要在同一张数据表中。因此，如果想要通过函数或关联字段进行排序，确保要设置store=True。如果要对继承自另一个模型的字段排序，声明一个存储的关联字段。

tree元素的create, edit和delete属性与我们在本章*向表单视图添加内容和微件*一节中所描述的作用相同。如果设置了editable属性它们还决定可进行哪些控制。

## 定义搜索视图

在打开列表视图时，会注意到右上角的搜索字段。如果在这里进行输入，可获取搜索推荐，还有一些预定义的过滤器可供选择。本节中将讲解如何定义这些推荐和选项。

### 如何实现...

1. 定义搜索视图：

   ```
   <record id="search_all_customers" model="ir.ui.view">
       <field name="model">res.partner</field>
       <field name="arch" type="xml">
           <search>
               <field name="name"/>
               <field name="category_id" filter_domain="[('category_id', 'child_of', self)]"/>
               <field name="bank_ids" widget="many2one"/>
               <filter name="suppliers" string="Suppliers" domain="[('supplier_rank', '>', 0)]"/>
               <group expand="0" string="Group By">
                   <filter string="Country" name="country" context="{'group_by':'country_id'}"/>
               </group>
           </search>
       </field>
   </record>
   ```

2. 设置动作来使用它：

   ```
   <record id="action_all_contacts" model="ir.actions.act_window">
       <field name="name">All Contacts</field>
       <field name="res_model">res.partner</field>
       <field name="view_mode">tree,form</field>
       <field name="search_view_id" ref="search_all_customers"/>
   </record>
   ```

在搜索框中输入内容时，即可通过名称、分类和银行账号字段来进行搜索。如果所搜索的为系统中银行账号的一个子字符串，甚至会搜出完整银行账号对应的内容。

![定义搜索视图](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021043005582813.png)

### 运行原理...

对于name，我们仅仅是将该字段列出供用户搜索，语法中的保留为默认，即对字符串字段的子字符串搜索。

对于分类我们做了一些有意思的操作。默认，搜索词作用于many2many字段触发器name_search，这时分类名的子串搜索。但根据分类结构，搜索你要找的分类或其子类可以非常方便。思考一下主分类邮件订阅者，其子分类为周订阅、月订阅及其它订阅类型。使用前面的搜索视图定义来搜索邮件订阅者会一次性给出订阅任意类型邮件的用户，这比搜索每种类型再合并结果要方便得多。

filter_domain属性可以包含任意作用域，因此不受在name属性中命名的相同字段的搜索限制，也不仅只能搜索单项。变量self是用户所填入的，也是在这里所唯一能使用的变量。

针对成员的默认搜索视图更详细的示例如下：

```
<field name="name"
    filter_domain="[
    '|', '|',
    ('display_name', 'ilike', self),
    ('ref', '=', self),
    ('email', 'ilike', self)]"/>
```

这表示用户不用考虑搜索什么。他们只需输入一些字母然后按下 Enter 键，即有可能包含我们要搜索的字符串。

对于bank_ids字段我们使用另一种技巧。字段的类型不仅决定对用户输入的默认搜索方式，还定义了Odoo呈现推荐的方式。还有既然many2one是唯一提供自动补全的字段，虽然bank_ids是一个one2many字段，我们通过设置 widget 属性来强制Odoo这么做。没有它，我们需要在没有补全推荐的情况下搜索该字段。对于many2many字段同样如此。

> 📝**注**：注意带有many2one微件的所有字段在用户每次按下键盘时会触发对于该模型的搜索，不要过度使用。

应该将最常使用的放在最上面，因为第一个字段是在用户输入内容并按下 Enter所进行的搜索。搜索框也可配合键盘使用，按向下键选择一条推荐，通过按向右键打开many2one的被全推荐。如果你告诉用户并注意维护搜索视图中的字段排序的话，这比先进行输入来得更有效率，只需要拿起鼠标选择一项即可。

filter元素创建一个按钮，将过滤器的domain属性添加到搜索域中。应该添加一个内部逻辑**name**和一个**string**属性来向用户描述过滤器。

<group>标签用于在Group by按钮下提供分组选项。本节中我们根据country_id对组记录添加了一个选项。

### 扩展知识...

可以使用group标签来对过滤器分组，这会让它们比其它过滤器离得更近一些，但这也有语法上隐含意思。如果将多个过滤器放在同一组中并激活一个以上的过滤器，它们会通过 | 运算符进行合并，而不在同一组中的过滤器和字段通过 & 运算符进行合并。有时，可能会希望拆分过滤器，即在它们进行互斥过滤时，此时选择两者会产生空结果集。在同一组中，我们可使用separator元素实现同等效果。

> 📝**注**：注意如果用户对相同字段填入了多条查询，它们也会通过 | 合并，因此不需要有什么担心。

除field的属性外，filter元素还可带有context属性，它的内容会与当前上下文合并，最终与搜索视图中的其它上下文属性合并。这对于支持分组的视图尤其必要（参见*定义看板视图*和*定义图表和透视表视图*小节），因为产生的上下文会决定通过group_by键分组的字段。我们会在相应章节中了解分组的细节，但上下文也有其它用途。例如，可以编写一个函数字段返回依赖于上下文的不同值，然后通过激活过滤器修改值。

搜索视图自身也对上下文键响应。在创建记录时它与默认值的方式非常相似，可以通过上下文向搜索视图传递默认值。如果我们在前面的动作中设置了{'search_default_suppliers': 1} 上下文，在搜索视图中会预选中供应商过滤器。但这仅在过滤器有名称时才能使用，因此应保持进行名称的设置。使用search_default_$fieldname在搜索视图中为字段设置默认值。

此外，field和filter元素可带有表单视图中语法相同的groups属性，来让该元素仅对某些组可见。

### 其它内容

- 更多有关操作上下文的内容，参见*向表单和动作传递参数 - 上下文*一节。
- 重度使用变音语言的用户可能在填写e时希望让Odoo搜索的是e, è, é和ê。PostgreSQL服务中有一项配置称为去重音（unaccent），Odoo 进行了特别的支持，但这在本书讨论的范畴之外。参见https://www.postgresql.org/docs/10/unaccent.html来了解更多有关去重音的知识。

## 添加搜索过滤器侧边栏

Odoo提供了另一种展示搜索过滤器的方式，即搜索过滤器侧边栏。这个侧边栏在视图的侧边显示一个过滤器列表。搜索侧边栏对于经常使用搜索过滤器的用户非常有用。

### 准备工作

搜索侧边栏是搜索视图的一部分。因此，本节中，我们将继续使用前一小节中的my_module插件。我们将对前面设计的搜索视图添加侧边栏。

### 如何实现...

在搜索视图中添加**<searchpanel>**，如下所示：

```
<record id="search_all_customers" model="ir.ui.view">
    <field name="model">res.partner</field>
    <field name="arch" type="xml">
        <search>
            <field name="name"/>
            <field name="category_id" filter_domain="[('category_id', 'child_of', self)]"/>
            <field name="bank_ids" widget="many2one"/>
            <filter name="suppliers" string="Suppliers" domain="[('supplier_rank', '>', 0)]"/>
            <group expand="0" string="Group By">
                <filter string="Country" name="country" context="{'group_by':'country_id'}"/>
            </group>
            <!--Search Panel code-->
            <searchpanel>
                <field name="user_id" icon="fa fa-users"/>
                <field name="category_id" icon="fa fa-list" select="multi"/>
            </searchpanel>
        </search>
    </field>
</record>
```

更新模块来应用修改。在更新后，就可以在视图的左侧看到搜索侧边栏了。

![添加搜索过滤器侧边栏](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021043006441912.png)

### 扩展知识...

添加搜索侧边栏需要在搜索视图中使用**<searchpanel>**标签。需要在搜索边栏中添加字段来添加过滤器。

本例中，我们首先添加了**user_id**字段。还需要对字段添加一个**icon**属性。图标显示在过滤器标题的前面。在搜索边栏中添加了字段之后，会显示图标和标题，在它们下面，显示所有用户的列表。点击用户之后，列表视图中的记录会进行过滤，只会看到指定用户的联系人。在这个过滤器中，只会有一个处于激活状态，也就是说点击另一个用户过滤器时，之前的用户过滤器会被移除。如果希望激活多用户过滤器，可以使用属性**select="multi"**。使用该属性后，会在每个过滤选项前看到有复选框，就可以一次启用多个过滤器。我们对**category_id**过滤器使用了**select="multi"**属性。这让我们可以一次选取、过滤多个分类。

> 📝**注**：在对**many2one**和**many2many**字段使用侧边栏过滤器时要小心。如果关联模型记录过多的话，为避免性能问题仅会显示前200条记录。

### 其它内容

如果希望显示分组显示搜索边栏内容的话，可以对使用字段使用groupby属性。本例中，如果希望分类按照父级进行分组，可以对**groupby**属添加**parent_id**字段，如下：

```
<field name="category_id" icon="fa fa-list" select="multi" groupby="parent_id"/>
```

这时在显示分类过滤器时会根据记录的父类分组。

![搜索侧边栏父类分组](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/202104300700006.png)

## 修改已有视图 - 视图继承

至此，我们都忽略了已有视图，声明的都是全新的视图。这在教学上讲得通，但实际是很少碰到为已有模型定义新视图的情况。而是对已有视图进行适当的修改，可能是显示在插件的模型中所添加的字段，或是根据自身或客户需求对它们进行自定义。

本节中，我们将修改默认的partner表单来显示记录的最后修改日期并通过修改搜索视图来让手机号字段可进行搜索。然后，我们会修改partner列表视图中一列的位置。

### 如何实现...

1. 在默认表单视图中插入字段：

   ```
   <record id="view_partner_form" model="ir.ui.view">
       <field name="model">res.partner</field>
       <field name="inherit_id" ref="base.view_partner_form"/>
       <field name="arch" type="xml">
           <field name="website" position="after">
               <field name="write_date"/>
           </field>
       </field>
   </record>
   ```

2. 向默认搜索视图添加字段：

   ```
   <record id="view_res_partner_filter" model="ir.ui.view">
       <field name="model">res.partner</field>
       <field name="inherit_id" ref="base.view_res_partner_filter"/>
       <field name="arch" type="xml">
           <xpath expr="." position="inside">
               <field name="mobile"/>
           </xpath>
       </field>
   </record>
   ```

3. 向默认列表视图添加字段：

   ```
   <record id="view_partner_tree" model="ir.ui.view">
       <field name="model">res.partner</field>
       <field name="inherit_id" ref="base.view_partner_tree"/>
       <field name="arch" type="xml">
           <field name="email" position="after">
               <field name="phone" position="move"/>
           </field>
       </field>
   </record>
   ```

在更新模块之后，你应该可以在partner表单的website字段下看到一个Last updated on字段。在搜索框中输入内容进行搜索时，会提示对成员进行手机号的搜索，在成员列表视图中，可以看到电话和email的顺序发生了变化。

![表单视图视图继承](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/202104300719126.png)

![列表和搜索视图视图继承](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021043007194876.png)

### 运行原理...

第1步中我们对表单继承添加了一个基础结构。你可能也猜到了，这里重要的字段是inherit_id。我们需要向其传递希望修改的视图（所继承的）的XML ID。arch字段包含对所继承的视图中XML节点如何进行修改的指令。实际上应该将整个过程看作简单的XML处理，因为语法在很靠后的地方才涉及。

继承视图的arch字段中最有份量的指令是field元素，带有必填属性name和position。因为每个字段在表单中仅能出现一次，name已唯一标识了字段。通过position属性，我们可以在field字段内放置任意内容，在我们所命名的字段之前，之中或之后均可。默认值为inside，但为保持代码的易读性，应当指定所需的位置。记住这里我们讨论的不是语法，这是有关XML树中相对于我们所命名字段的位置。稍后是如何渲染的完全是另一个话题。

第2步演示了一种不同的方法。xpath元素选取与expr属性中指定的XPath表达式所匹配的第一个元素。这里，position属性告知处理器在何处安放xpath元素中的内容。

> 📝**注**：如果希望根据CSS类创建XPath表达式，Odoo提供了一个特殊的函数**hasclass。**例如，如果希望选取CSS类名为**test_class**的
>
> 元素，表达式为expr="//div[hasclass('test_class')]"。

第3步展示了如何更改一个元素的位置。这一选项在版本 12中引入并很少被使用。本例中，通过position=move选项将phone字段移到了email字段之后。

XPath看起来好像很可怕，但对于选择需要操作的节点是一种非常有效的工具。花点时间在仔细阅读一些简单的表达式是非常值得的。你可能会撞上context node（上下文节点）一词，一些表达式与其相关。在Odoo的视图继承体系中，它总是所要继承视图的根元素。

对于在继承视图的arch字段中的其它元素，处理器查找带有相同节点名和匹配属性（排除掉position属性，因为它是指令的一部分）的第一个元素。仅在这个组合很可能不是唯一的时候使用它，比如group元素与name属性进行的组合。

> **📝重要贴士：**注意你可以在arch元素中加任意所需数量的指令元素。我们在继承视图中仅使用了一个，因为当前我们并不需要进行其它修改。

### 扩展知识...

The **position** attribute has two other possible values: **replace** and **attributes**. Using **replace** causes the selected element to be replaced with the content of the instruction element. Consequently, if you don't have any content, the selected element can simply be removed. The preceding list or form view would cause the **email** field to be removed:

position属性有另外两个值可以使用：replace和attributes。使用replace会让所选元素被指令元素的内容所替换。如果没有任何内容的话所选元素会被删除。在前面的列表或表单视图中会让email字段被删除：

```
<field name="email" position="replace" />
```

> ⚠️**警告**
>
> 删除字段会导致破坏其它继承视图以及一些不想要的负面效果，因此要尽量避免。如果实在需要删除字段，在运行顺序靠后的视图中使用（参见下一节*视图继承中的运行顺序*，获取更多相关知识。）

attributes与前例有着非常不同的语法。处理器预设该元素是name 属性、名为attribute的元素。然后用这些元素设置所选元素的属性。如果要遵照前面的警告，应当对email设置invisible属性为1：

```
<field name="email" position="attributes">
 	<attribute name="invisible">1</attribute>
</field>
```

attribute节点可包含add和remove属性，其中又包含加入空格分隔列表的待添加或待删除值。这对于 class 属性非常有用，可以通过如下代码添加一个class（而非覆盖整个属性）：

```
<field name="email" position="attributes">
 	<attribute name="class" add="oe_inline" />
</field>
```

这段代码对email字段添加一个oe_inline类。如果字段已有类属性，Odoo会使用separator属性的值拼接该值。

 

